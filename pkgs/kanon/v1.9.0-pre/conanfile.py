from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps
from conan.tools.files import get
from conan.tools.scm import Git
import os

class KanonRecipe(ConanFile):
    name = "kanon"
    version = "1.9.0-pre"

    # Optional metadata
    license = "MIT"
    author = "Conzxy zengxiaoyu0@gmail.com"
    url = "https://github.com/Conzxy/kanon"
    description = "Event-driven network library"
    topics = ("linux", "windows", "poll", "epoll", "iocp", "cmake", "high-performance", "multi-threading",
              "cpp11", "reactor", "event-driven", "eventloop", "nonblocking-io", "callback-api", "network-programming")

    # Binary configuration
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "protobuf": [True, False],
        "proto_rpc": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "protobuf": False,
        "proto_rpc": False,
    }

    # Sources are located in the same place as this recipe, copy them to the recipe
    # exports_sources = "CMakeLists.txt", "src/*", "include/*"

    def source(self):
        git = Git(self)
        # target is the target directory to put contents
        git.clone(url="https://github.com/Conzxy/kanon.git", target='.')
        self.run('git submodule update --init --recursive')

    def config_options(self):
        if self.settings.os == "Windows":
            self.options.rm_safe("fPIC")

    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def layout(self):
        # For pacakge and ediable mode
        self.folders.source = '.'

        # build/Debug
        # build/Release
        # Avoid clean build when switch between debug and release
        self.folders.build = os.path.join("build", str(self.settings.build_type))

        # default
        self.folders.generators = os.path.join(self.folders.build, "generators")
        
        # Use the xxxConfig.cmake generated by CMakeLists.txt of project
        # No need to set the package include and libdirs

        # Equivalant to set the self.cpp_info.includedirs in package_info()
        # self.cpp.package.includedirs = ["include"] # includedirs is already set to 'include' by
        #                                            # default, but declared for completion

        # Equivalant to set the self.cpp_info.libdirs in package_info()
        # self.cpp.package.libdirs = ["lib"]         # libdirs is already set to 'lib' by

        # Default is enough
        
        # self.cpp.source.includedirs = ['.']
        # self.cpp.build.libdirs = ['lib/release/debug']
        
        # Use the xxxConfig.cmake generated by CMakeLists.txt of project
        # No need to set the ediable include and libdirs

        # Append this to `CMAKE_MODULE_PATH`
        # Equivalant to set the self.cpp_info.builddirs in package_info()
        self.cpp.build.builddirs.append('.') # Relative to the self.folders.build

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)

        tc.variables["KANON_BUILD_PROTOBUF"] = self.options.protobuf
        tc.variables["KANON_BUILD_PROTOBUF_RPC"] = self.options.proto_rpc
        tc.variables["KANON_BUILD_STATIC_LIBS"] = not self.options.shared
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        self.cpp_info.set_property("cmake_find_mode", "none")
        # Relative to the package folders
        # e.g. relative to the ~/.conan2/p/xxxx12312123a4/p/
        self.cpp_info.builddirs.append('lib/cmake/kanon')
        # self.cpp_info.set_property("cmake_find_mode", "module")
