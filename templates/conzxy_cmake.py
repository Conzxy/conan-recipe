from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMake, cmake_layout, CMakeDeps
from conan.tools.files import get
from conan.tools.scm import Git
import os

class Recipe(ConanFile):
    name = ""

    """
    The version follow the semantic versioning format:
    MAJOR.MINOR.PATCH-prelease+build

    The '-' indicates this is a pre release version.

    To requires, the prelease version isn't included.
    Consumer can use xxxx/[>=xx.xxx-] to enable.
    """
    version = ""

    license = ""
    author = "Conzxy zengxiaoyu0@gmail.com"
    url = "https://github.com/Conzxy/"
    description = ""
    topics = ()

    # Binary configuration
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
    }

    def source(self):
        git = Git(self)
        """
        target: The target directory that put contents
        """
        git.clone(url=self.url, target='.')
        # self.run('git submodule update --init --recursive')

    def config_options(self):
        if self.settings.os == "Windows":
            self.options.rm_safe("fPIC")

    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")

    def layout(self):
        """
        reference:
         https://docs.conan.io/2/tutorial/developing_packages/package_layout.html#developing-packages-layout
        """
            
        """
        self.folders is independent and can be used for pacakge and ediable mode.
        It is convenient for latter configuration.
        """
        
        """
        Usually, this is the project root directory.
        To CMake, it is the directory contains root CMakeLists.txt.
        """
        self.folders.source = '.'

        """
        Pushing build artifacts to `build/Debug` in Debug mode and 
        pushing them to `build/Release` in Release mode.

        Follow this convention, it can avoid clean build when 
        switch between debug and release
        """
        self.folders.build = os.path.join("build", str(self.settings.build_type))

        # default
        self.folders.generators = os.path.join(self.folders.build, "generators")
        
        """
        The `cpp.package` set the package information.

        If you install and use the `xxxConfig.cmake` generated by CMakeLists.txt of project,
        there is no need to set the package `includedirs`, `libdirs` and `libs`.
        Otherwise, you should set the `self.cpp.package` or `self.cpp_info` in `package_info()`.

        The install of include and lib directory can be handled by 
        `install()` command of `CMake` or
        copy files to them depends on your taste.
        """

        """
        Equivalant to set the `self.cpp_info.includedirs` in `package_info()`
        """
        # self.cpp.package.includedirs = ["include"] # includedirs is already set to 'include' by
        #                                            # default, but declared for completion
        
        """
        Equivalant to set the `self.cpp_info.libdirs` in `package_info()`
        """
        # self.cpp.package.libdirs = ["lib"]         # libdirs is already set to 'lib' by

        """
        Equivalant to set the `self.cpp_info.libs` in `package_info()`
        """
        # self.cpp.package.libs = [] 

        
        """
        The `cpp.source` and `cpp.build` type is `CppInfo` that is same with 
        the `self.cpp_info` in `package_info()`.
        So you can set `builddirs`, `includedirs`, `libs` of them.

        Note:
            There is not necessary to set self.cpp.build.libs = [..] here
            since conan will merge the the `self.cpp.source` and `self.cpp.build`
            with the same information in the `self.cpp.package`, so libs can be same 
            with the `self.cpp.package.libs`.

        refernece:
            https://docs.conan.io/2/tutorial/developing_packages/package_layout.html

        If you install and use the xxxConfig.cmake generated by CMakeLists.txt of project,
        there is no need to set the editable include and libdirs.
        Otherwise, you should set them to correct value.
        """
        # self.cpp.source.includedirs = ['.']
        # self.cpp.build.libdirs = ['lib/release']
        # or self.cpp.build.libdirs = ['lib/debug']

        """
        Append `build/(Release|Debug)/` to the `CMAKE_MODULE_PATH`.

        Like the setting of `self.cpp_info.builddirs` in `package_info()`
        but this is designed for ediatble mode.

        Make CMake can search the build directory to get `xxx-config.cmake` and cmake files.
        """
        self.cpp.build.builddirs.append('.') # Relative to the self.folders.build

    def generate(self):
        deps = CMakeDeps(self)
        deps.generate()
        tc = CMakeToolchain(self)
      
        """
        You can set cmake variable in toolchain.
        e.g. tc.variables["xxx"] = self.options.xxxx
        """
        tc.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        """
        To editable mode, this will not be called
        """
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        """
        Relative path to the package folder
        e.g. relative to the `~/.conan2/p/xxxx12312123a4/p/`
        """
        self.cpp_info.builddirs.append('lib/cmake/kanon')

        """
        If you don't install the `xxx-config.cmake/xxxConfig.cmake`,
        you can set this to `config`/`module`/`both` and set libs
        and include.
        """
        self.cpp_info.set_property("cmake_find_mode", "none")

        # self.cpp_info.includedirs = []
        # self.cpp_info.libdirs = []
